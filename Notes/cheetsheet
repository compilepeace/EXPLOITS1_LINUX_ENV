

~~~~~~~~~~~~~

$ tcc -g -o simple_login simple_login.c
$ gdb -q simple_login



~~~~~~~~~~~~ GOT OVERWRITE (OR IMPORT ADDRESS TABLE (in Windows)) 

$ objdump -R ./executable_elf		# shows where the GOT/Dynamic Relocation entries which will be 
									# placed at by the linker at runtime. The values at these entries
									# will be zero at this time but will be filled up by the linker
									# with appropriate addresses at runtime (i.e. when we execute the
									# binary with ./executable_elf command).
a.out:     file format elf64-x86-64

DYNAMIC RELOCATION RECORDS
OFFSET           TYPE              VALUE 
0000000000201f98 R_X86_64_JUMP_SLOT  memcmp@GLIBC_2.2.5
0000000000201fa0 R_X86_64_JUMP_SLOT  strcmp@GLIBC_2.2.5
0000000000201fa8 R_X86_64_JUMP_SLOT  listen@GLIBC_2.2.5
0000000000201fb0 R_X86_64_JUMP_SLOT  bind@GLIBC_2.2.5
0000000000201fc0 R_X86_64_JUMP_SLOT  accept@GLIBC_2.2.5
0000000000201fd0 R_X86_64_JUMP_SLOT  socket@GLIBC_2.2.5

#	These addresses (offsets in this case) (eg: 0000000000201fd0) will contain zero at this time and 
	will be filled up at runtime by the linker. (since the executable is dynamically linked and 
	code to these functions will be used by shared library i.e. libc in linux and DLL's in windows)


#	Whenever we keep printf() simple, i.e. we do not give arguments to printf() other than a string,
	the compiler optimizes the code by putting 'puts()' in place of 'printf()'.

	printf("hell %s\n", string_pointer);		// remains the same
	printf("Hello there\n");					// converted into 'puts()' for optimization


#	Libc and GOT are loaded for every executable's process separately and as a programmer we have no
	idea where it will get loaded. We rely on OS/linker to fix up those values in GOT so that we can
	use libc or other shared library. Every process has its unique GOT and is made on per process 
	basis.



# mov eax, PTR DWORD [ebp-0x10]		# Typecast the value at $ebp-0x10 into a PTR address and then 
									# store it into eax register


~~~~~~~~~~~~~ DESTRUCTOR TABLES (.DTORS SECTION)


$ objdump -s -j .dtors ./executable_elf

Contents of section .dtors:
8049590: ffffffff 00000000


#	The .dtor section contains a list of entries. The list above is starting at (0x8049590) and the 
	first entry is '0xffffffff' (which is kind of a sanity check) and the second entry is 
	'0x00000000' specifying that the list is empty. Therefore we have to overwrite the value at	
	(0x8049590 + 0x4) here.


#	The destructors section (.DTORS) is added to GCC compiled binaries. 

#	Whenever a GCC compiled program exits, it calls any function registered in the .DTORS section of
	the ELF binary. 


~~~~~~~~~~~~~ gdb commands

> disass main				# To disassemble main
> break *main+9				# set a breakpoint on line <main+9>
> r							# run
> c							# continue
> x/10x $esp				# examine 10 hexadecimal words from esp
> x/70xb $esp				# examine 70 hexadecimal bytes from $esp 

> define hook-stop			# define a list of commands that gets executed until the next breakpoint
info registers				# shows out the values of all registers
x/5i $eip					# display next 5 assembly instructions that eip will point to 
end							# end the hook-stop

> x/10c $esp				# examine 10 byte characters starting from esp
> where						# backtrace the stack frames till now
> printf "%d", $esp-$ebp

> info proc mapping
> info func					

> set $i1 = (struct heap_metadata *)0x804a008
> print *$i1
$2 = {priority = 1, name = 0x0}



~~~~~~~~~~~~ HANDY COMMANDS
$ xxd -g 1 payload_file					# To examine payload in hex bytes and spot probleums



~~~~~~~~~~~~~ Exploitation input:

$ simple_login < login_input		# This executes the go_shell() but does not spawn the shell. Why?
=>	The redirection symbol ('<') passes on 'login_input' file as input to the 'simple_login' program.
	But along with the input, it also passes the EOF (End Of File) character to the program. So, our
	shell does spawn, but after seeing the EOF character (Ctrl+D), it exits.

$ (cat payload; cat -) | ./program_name


~~~~~~~~~~~~~ Hexedit Binaries

$ hexedit binary_name 



~~~~~~~~~~~~~ Linux Handy commands

If you don't get your shellcode executed, its because gdb messes up a bit with stack and when running
the binary outside the gdb, the stack addresses are'nt same as in debugger. To look at how the 
process's image looked like at the time of crash, we see generate a core dump and load it inside
gdb with vulnerable_program

$ ulimit -c unlimited				# This will cause linux to dump the core
$ ./prog_name						# Now run the program, if it crashes, core dump will be generated
(Illegal instruction) (core dumped)
$ gdb ./prog_name core				# Loads the core file so that we can inspect 
.
.
.
#0 0xbffff522 in ?? ()
(gdb) x/20i 0xbffff522
.
.
. and analyses where is your shellcode



~~~~~~~~~~~~~~


~~	BYPASSING DEP

# To identify where our 'libc library' is stored

$ ldd ./executable_elf
linux-gate.so.1 => (0xffffe000)
libc.so.6 => /lib/libc.so.6 (0xb7e89000)
/lib/ld-linux.so.2 (0xb7fe5000
